---
title: "Disaster Relief Project: Part I"
author: "Quinton Mays"
date: "`r format(Sys.Date(), '%b %d, %Y')`"
output:
  html_document:
    number_sections: true    
    toc: true
    toc_float: true
    theme: cosmo
    highlight: espresso    
# You can make the format personal - this will get you started:  
# https://bookdown.org/yihui/rmarkdown/html-document.html#appearance_and_style    
---

<!--- Below are global settings for knitr. You can override any of them by adding the changes to individual chunks --->

```{r global_options, include=FALSE}
knitr::opts_chunk$set(error=TRUE,        # Keep compiling upon error
                      collapse=FALSE,    # collapse by default
                      echo=TRUE,         # echo code by default
                      comment = "#>",    # change comment character
                      fig.width = 5.5,     # set figure width
                      fig.align = "center",# set figure position
                      out.width = "80%", # set width of displayed images
                      warning=TRUE,      # show R warnings
                      message=TRUE,
                      cache = TRUE) 
```

<!--- Change font sizes (or other css modifications) --->
<style>
h1.title {
  font-size: 2.2em; /* Title font size */
}
h1 {
  font-size: 2em;   /* Header 1 font size */
}
h2 {
  font-size: 1.5em;
}
h3 { 
  font-size: 1.2em;
}
pre {
  font-size: 0.8em;  /* Code and R output font size */
}
</style>



**DS 6010 | Summer 2021 | University of Virginia **

*******************************************

# Introduction 

At around 5:00 PM on January 12th, 2010, a magnitude 7.0 earthquake struck just west of Port-au-Prince, Haiti. The earthquake may have caused over 100,000 deaths, destroyed much of the islands infrastructure, and displaced millions of residents. In the immediate aftermath of the quake, many Haitians chose to shelter under tarps due to the risk of aftershocks causing buildings damaged by the earlier earthquake to collapse. Due to the damage to critical transportation and communications infrastructure, and the country's geography, coordination of relief efforts proved difficult because displaced persons were hard to locate. 

To help locate refugees, a team from the Rochester Institute of Technology surveyed the affected region using aerial photography. Due to the scale of the disaster, a large land area needed to be covered, making the task of manually identifying photographs with blue tarps in them very resource intensive process. Therefore, an algorithm needed to be determined that could quickly and accurately locate potential displaced persons so that humanitarian aid resources could be deployed to those areas.

This project will focus on determining the appropriate algorithm for this application. 

# Training Data / EDA

The following R packages were utilized in this project:

```{r load-packages, warning=FALSE, message=FALSE}
library(tidyverse)
library(skimr)
library(GGally)
library(caret)
library(broom)
library(yardstick)
library(class)
library(plotly)
library(plotROC)
```

The data was supplied in the form of a .csv file. The function `read_csv` from the package `tidyverse` was utilized to read in and store the data in a data frame object called `raw_data`. This data frame will serve as the record of the as-received data.
```{r import-data}
raw_data <- read_csv('HaitiPixels.csv', 
                     col_types = list(col_factor(),
                                      col_double(),
                                      col_double(),
                                      col_double()))
```

Next, the `skimr` package was utilized to provide a summary of the imported data:

```{r explore-data-skim}
skim(raw_data)
```

The skim indicates that the dataframe contains four variables: the `Red`, `Blue`, and `Green` (RGB) color intensity of each pixel, which ranges from 0 to 255, and the classification of the pixel contents 'Class`, which is summarized in the table below:
```{r}
knitr::kable(table(raw_data$Class), col.names = c('Class',
                                                  'Observations'))
```

There are five levels within the categorical variable `Class`. The target class, Blue Tarp, only makes up a small portion of the data contained in this dataset. This is not surprising, as the dataset contains pixel information for a large area of land, with only a small portion of the land occupied by refugees. 

Next, the function `ggpairs` from the package `Ggally` was used to visualize data distributions and correlations:
```{r plot-ggally, message=FALSE, warning=FALSE, out.width = '90%'}
ggpairs(raw_data)
```

There are several points of interest in the `ggpairs` plot. First, the color values seem to be highly correlated with one another. Second, for the blue tarp classification, the blue value appears to be higher on average than the other classes. This can also be observed in the density curve for blue values, where there is a large concentration of blue values around 200.

# Model Training

## Set-up

After conducting the exploratory data analysis, a working copy of the raw data was saved into a new dataframe called `df`.
```{r establish-working-data}
df = raw_data
```

During exploratory data analysis, it was observed that the variable of interest, Class, has five levels. As the objective of this project is to predict if the pixel color values associated with a given area indicates if refugees are sheltering in this area, this categorical variable was collapsed from five classes to two classes. The new classes, `BT` (Blue Tarp) and `NBT` (Not Blue Tarp) will be the levels of the new response variable, `collpase.Class`. In addition, the seed 304 was chosen for repeatable random splits for cross validation. 

```{r collapseclass, message=FALSE, warning=FALSE}
set.seed(304)
df$collapse.Class = as.factor(ifelse(df$Class == "Blue Tarp", "BT", "NBT"))
df = subset(df, select = -Class)
df$collapse.Class = relevel(df$collapse.Class, ref = "NBT")
df$collapse.Class <- factor(df$collapse.Class, levels=rev(levels(df$collapse.Class)))
plot_preds = data.frame(df$collapse.Class)
```

After collapsing the response variable, the `contrasts` function was used to check the leveling in `collapse.Class`:

```{r check-contrasts}
contrasts(df$collapse.Class)
```

A summary of the new variable `collapse.Class` can be found below:
```{r collapsetable}
knitr::kable(table(df$collapse.Class), col.names = c('Class',
                                                     'Observations'))
```

It is clear that the count of pixels where the positive response, `BT`, is observed is sparse compared to the overall number of pixels observed. After the reduction in the number of levels in `Class`, the distribution of data in the 3D parameter space can be visualized with clarity. The package `plotly` was used to generate an interactive 3D scatter plot of each of the observations. 

```{r 3d-eda, out.width = '90%'}
fig <- plot_ly(df, x = ~Red, y = ~Green, z = ~Blue, color = ~collapse.Class, colors = c('#0C4B8E','#BF382A'))
fig <- fig %>% add_markers()
fig <- fig %>% layout(title = 'Distribution of Observations in 3D Parameter Space',
                      scene = list(xaxis = list(title = 'Red'),
                                   yaxis = list(title = 'Green'),
                                   zaxis = list(title = 'Blue')))

fig
```

The scatter plot indicates that there is a somewhat clear distinction between the classes `BT` and `NBT`, with BT pixels having higher Blue values than NBT pixels. However, it is unclear what form the decision boundary should take to create an optimal classification model for this data. Therefore, several classification models were considered including:

* Logistic Regression
* Linear Discriminant Analysis (LDA)
* Quadratic Discriminant Analysis (QDA)
* K-Nearest Neighbors (KNN)
* Penalized Logistic Regression (ElasticNet)

To begin the model selection a function, `trainControl`, from the `caret` package was utilized to set up a 10-fold cross validation to evaluate each of the models. Additional parameters were added to save the calculated probabilities for each observation, to save the predictions from the cross validation, and to allow for parallel processing. 

```{r setuptraincontrol}
ctrl = trainControl(method = 'cv',
                    number = 10,
                    classProbs = TRUE,
                    savePredictions = TRUE,
                    allowParallel = TRUE)
```

## Logistic Regression

The first model examined was a logistic regression model. The function `train` from the package `caret` was used to fit a model to predict `collapse.Class` using the predictors `Red`, `Green`, and `Blue`. The model was then evaluated using a 10-fold cross validation that was setup with the `trainControl` function.

```{r train-logistic, message=FALSE, warning=FALSE}
model.logistic = train(form = collapse.Class~., 
                       data = df,
                       method = 'glm', 
                       trControl = ctrl,
                       family = 'binomial',
                       trace = FALSE)
model.logistic
model.logistic$finalModel %>% broom::tidy()
```

The output from the cross validation indicates that this model has very high accuracy (`r model.logistic$results$Accuracy*100`%). The model form also indicates that all of the predictors chosen (red, green, and blue) are highly important in predicting if a blue tarp is present (no p-values over $10^{-50}$!) However, accuracy is not the only characteristic of the model that is important for this application, as it is important that the model correctly identifies areas that have blue tarps and does not waste aid resources by incorrectly labeling areas that do not contain blue tarps as containing them. To further investigate the logistic regression model's performance, a confusion matrix is needed:

```{r logsitic-cv-cm}
confusionMatrix(model.logistic)
```

The cross-validation confusion matrix indicates that the model has a sensitivity, or percentage of correctly identified blue tarp areas out of all blue tarp areas of 87.5% and a specificity, or percentage of correctly identified non-blue tarp areas out of all non-blue tarp areas of 99.9%.  This confusion matrix is generated using a cutoff value of 0.5, which may not be optimal for this model, as identification of blue tarp areas is of more value than correct identification of non-blue tarp areas. To begin investigating the ideal cutoff value, the model's Receiver Operating Characteristic (ROC) curve is generated:

```{r logistic-roc, message=FALSE, warning=FALSE, out.width = '90%'}
r = ggplot(model.logistic$pred, aes(m = BT, d = obs)) + 
  geom_roc(labels = FALSE, increasing = FALSE) +
  labs(title = 'ROC Curve for Logistic Regression Model') +
  xlab('False Negative Rate') +
  ylab('True Positive Rate')
r + annotate("text", x = .8, y = .15, label = paste("AUC =", round(calc_auc(r)$AUC, 4)))
```

The ROC curve's proximity to the top left of the plot and it's associated area under the curve (AUC) above indicates that the logistic regression model performs very well at predicting if a given pixel represents a blue tarp or not. To determine the optimal cutoff value for the model, an interactive plot was created to explore the model's performance metrics for different cutoff values:

```{r logistic-cutoff, out.width = '90%'}
sens = c()
spec = c()
acc = c()
tnr = c()
cutoff = seq(0, 1, by=0.01)
for (i in 1:length(cutoff)){
  newpred = factor(ifelse(model.logistic$pred$BT > cutoff[i], "BT", "NBT"), levels = c("BT", "NBT"))
  sens[i] = sens_vec(model.logistic$pred$obs, newpred)
  spec[i] = spec_vec(model.logistic$pred$obs, newpred)
  acc[i] = accuracy_vec(model.logistic$pred$obs, newpred)
  tnr[i] = 1 - spec[i]
}
cutoff_plot_data = data.frame(Cutoff = cutoff, Sensitivity = sens, Specificity = spec, Accuracy = acc, TNR = tnr)
p = ggplot(reshape2::melt(cutoff_plot_data, id.var='Cutoff')) +
  geom_line(aes(x = Cutoff, y = value, color = variable)) +
  scale_x_continuous(limits = c(0,1), breaks = seq(0,1,0.1)) +
  labs(title = 'Logistic Regression Model Performance by Cutoff Value') +
  xlab('Probability Cutoff Value')
ggplotly(p, dynamicTicks = TRUE) %>% rangeslider() %>% layout(hovermode = 'x')
```

After investigating the interactive plot, a cutoff value of 0.1 was selected for the model. The associated confusion matrix for this value is shown below:

```{r logistic-cm}
newpred = factor(ifelse(model.logistic$pred$BT > 0.1, "BT", "NBT"), levels = c("BT", "NBT"))
plot_preds = cbind(plot_preds,newpred)
logistic.cm = confusionMatrix(newpred, model.logistic$pred$obs)
logistic.cm
```

Using a cutoff of 0.1 improves the model's sensitivity from 87.5% to 96.5% while only reducing its specificity from 0.995 to 0.991, which represents a large improvement in the model's utility to aid workers.

A summary of the logistic regression model with the selected cutoff value can be found below:
```{r logistic-results, message=FALSE, warning=FALSE}
logistic.results = data.frame(Model = 'Logistic Regression', Tuning = 'NA', AUROC = round(calc_auc(r)$AUC, 4), Threshold = 0.1, Accuracy = round(logistic.cm$overall[[1]],4), TPR = round(logistic.cm$byClass[[1]],4), FNR = round(1-logistic.cm$byClass[[2]],4), Precision = round(logistic.cm$byClass[[5]],4))
knitr::kable(logistic.results)
```

## LDA

The next model that was explored was a linear discriminant analysis (LDA) model. LDA may improve on the performance of the logistic regression model by generating a linear decision boundary that maximized the separation between the two classes. The model was trained using the `train` method of the `caret` class and evaluated using a 10-fold cross validation:

```{r train-lda}
model.lda = train(collapse.Class~., 
                  data = df, 
                  method = 'lda', 
                  trControl = ctrl, 
                  trace = FALSE)
model.lda
model.lda$finalModel
```

Again, the initial model fit shows promising accuracy. Further investigation using the model's confusion matrix and ROC curve is shown below:

```{r lda-cv-cm}
confusionMatrix(model.lda)
```
```{r lda-roc, message=FALSE, warning=FALSE, out.width = '90%'}
r = ggplot(model.lda$pred, aes(m = BT, d = obs)) + 
  geom_roc(labels = FALSE, increasing = FALSE) +
  labs(title = 'ROC Curve for Linear Discriminant Analysis (LDA) Model') +
  xlab('False Negative Rate') +
  ylab('True Positive Rate')
auc = round(calc_auc(r)$AUC, 4)
r + annotate("text", x = .8, y = .15, label = paste("AUC =", round(calc_auc(r)$AUC, 4)))
```

The confusion matrix for the LDA model indicates that the model has an accuracy of `r model.lda$results$Accuracy *100`%. The ROC curve proximity to the upper left of the plot area and associated $AUC = `r auc`$, indicates that this model performs very well at categorizing blue tarp vs not blue tarp pixels overall. However, this is not the ideal measure of the performance of the model, as the 0.5 probability threshold used when generating the confusion matrix yields a True Positive Rate of $\dfrac{2.6}{2.6 + 0.6} = 0.8125$. The low TPR associated with the 0.5 cutoff is most likely due to the relative sparsity of BT data points compared to NBT data points, as seen in the EDA section. A low TPR is not ideal, as the model may classify blue tarp areas as non-blue tarp areas, causing the deployment of resources to endangered people to be slowed. Choosing another value for the cutoff value may improve the performance of the model. The performance metrics for the LDA model at different cutoff values is shown below:

```{r lda-cutoff, out.width = '90%'}
sens = c()
spec = c()
acc = c()
tnr = c()
cutoff = seq(0, 1, by=0.01)
for (i in 1:length(cutoff)){
  newpred = factor(ifelse(model.lda$pred$BT > cutoff[i], "BT", "NBT"), levels = c("BT", "NBT"))
  sens[i] = sens_vec(model.lda$pred$obs, newpred)
  spec[i] = spec_vec(model.lda$pred$obs, newpred)
  acc[i] = accuracy_vec(model.lda$pred$obs, newpred)
  tnr[i] = 1 - spec[i]
}
cutoff_plot_data = data.frame(Cutoff = cutoff, Sensitivity = sens, Specificity = spec, Accuracy = acc, TNR = tnr)
p = ggplot(reshape2::melt(cutoff_plot_data, id.var='Cutoff')) +
  geom_line(aes(x = Cutoff, y = value, color = variable)) +
  scale_x_continuous(limits = c(0,1), breaks = seq(0,1,0.1)) +
  labs(title = 'LDA Model Performance by Cutoff Value') +
  xlab('Probability Cutoff Value')
ggplotly(p, dynamicTicks = TRUE) %>% rangeslider() %>% layout(hovermode = 'x')
```

The interactive plot above indicates that choosing a cutoff value of 0.05 to produce a blue tarp prediction improves the TPR of the model by 5%, to 86%. While not ideal, this improvement could result in the correct identification of many more temporary shelters to bring relief aid to. The confusion matrix for a cutoff of 0.05 is shown below:

```{r lda-cm}
newpred = factor(ifelse(model.lda$pred$BT > 0.05, "BT", "NBT"), levels = c("BT", "NBT"))
plot_preds = cbind(plot_preds,newpred)
lda.cm = confusionMatrix(newpred, model.lda$pred$obs)
lda.cm
```

A summary table for the LDA model performance is shown below:

```{r lda-results, message=FALSE, warning=FALSE}
lda.results = data.frame(Model = 'LDA', Tuning = 'NA', AUROC = round(calc_auc(r)$AUC, 4), Threshold = 0.1, Accuracy = round(lda.cm$overall[[1]],4), TPR = round(lda.cm$byClass[[1]],4), FNR = round(1-lda.cm$byClass[[2]],4), Precision = round(lda.cm$byClass[[5]],4))
knitr::kable(lda.results)
```

## QDA

The next model explored was a quadratic discriminant analysis (QDA) model. Like LDA, QDA generates a decision boundary between the classes that maximizes the separation between each class, however QDA does not assume that the classes have equal variance, and therefore provides a more flexible model fit and quadratic decision boundary, which may be useful in this case, where the decision boundary may be non-linear. Again, the model was trained using the `train` method of the `caret` class.

```{r train-qda}
model.qda = train(collapse.Class~., 
                  data = df, 
                  method = 'qda', 
                  trControl = ctrl, 
                  trace = FALSE)
model.qda
model.qda$finalModel
```

The QDA results shown above are promising, the overall model accuracy has improved to 99%. A confusion matrix was generated for the 10-fold cross validation to visualize model performance at a cutoff value of 0.5:

```{r qda-cv-cm}
confusionMatrix(model.qda)
```

The confusion matrix indicates that the QDA model outperforms the linear discriminant analysis and is nearly identical to the performance of the logistic regression model. Next a receiver operating characteristic (ROC) curve was generated to visualize the model performance across all cutoff values:

```{r qda-roc, message=FALSE, warning=FALSE, out.width = '90%'}
r = ggplot(model.qda$pred, aes(m = BT, d = obs)) + 
  geom_roc(labels = FALSE, increasing = FALSE) +
  labs(title = 'ROC Curve for Quadratic Discriminant Analysis (QDA) Model') +
  xlab('False Negative Rate') +
  ylab('True Positive Rate')
auc = round(calc_auc(r)$AUC, 4)
r + annotate("text", x = .8, y = .15, label = paste("AUC =", round(calc_auc(r)$AUC, 4)))
```

The performance of the QDA model is nearly identical to the logistic regression model, with an AUC of `r auc`. Next, the cutoff value was optimized to balance sensitivity and specificity. The interactive plot below was utilized to select an optimal cutoff value:

```{r qda-cutoff, out.width = '90%'}
sens = c()
spec = c()
acc = c()
tnr = c()
cutoff = seq(0, 1, by=0.01)
for (i in 1:length(cutoff)){
  newpred = factor(ifelse(model.qda$pred$BT > cutoff[i], "BT", "NBT"), levels = c("BT", "NBT"))
  sens[i] = sens_vec(model.qda$pred$obs, newpred)
  spec[i] = spec_vec(model.qda$pred$obs, newpred)
  acc[i] = accuracy_vec(model.qda$pred$obs, newpred)
  tnr[i] = 1 - spec[i]
}
cutoff_plot_data = data.frame(Cutoff = cutoff, Sensitivity = sens, Specificity = spec, Accuracy = acc, TNR = tnr)
p = ggplot(reshape2::melt(cutoff_plot_data, id.var='Cutoff')) +
  geom_line(aes(x = Cutoff, y = value, color = variable)) +
  scale_x_continuous(limits = c(0,1), breaks = seq(0,1,0.1)) +
  labs(title = 'QDA Model Performance by Cutoff Value') +
  xlab('Probability Cutoff Value')
ggplotly(p, dynamicTicks = TRUE) %>% rangeslider() %>% layout(hovermode = 'x')
```

It is clear that beyond a cutoff of 0.1, model performance is not very much improved, therefore a confusion matrix was generated using a cutoff value of 0.1.

```{r qda-cm}
newpred = factor(ifelse(model.qda$pred$BT > 0.1, "BT", "NBT"), levels = c("BT", "NBT"))
plot_preds = cbind(plot_preds,newpred)
qda.cm = confusionMatrix(newpred, model.qda$pred$obs)
qda.cm
```

Using a cutoff of 0.1, the model's TPR improves from 84.4% to 90.0%. The chosen cutoff has increased the sensitivity by nearly 6% while only decreasing the global model accuracy by less than a percent.

A summary table of the QDA model results can be found below:

```{r qda-results, message=FALSE, warning=FALSE}
qda.results = data.frame(Model = 'QDA', Tuning = 'NA', AUROC = round(calc_auc(r)$AUC, 4), Threshold = 0.1, Accuracy = round(qda.cm$overall[[1]],4), TPR = round(qda.cm$byClass[[1]],4), FNR = round(1-qda.cm$byClass[[2]],4), Precision = round(qda.cm$byClass[[5]],4))
knitr::kable(qda.results)
```

## KNN

The next model tested was a K-Nearest Neighbors (KNN) model. While the parametric models have all shown to be quite accurate in predicting the presence of tarps, perhaps the non-parametric and highly flexible KNN model will yield better results.

### Tuning Parameter $k$

The first step in selecting the KNN model is to determine the optimal value for $k$, or how many neighbors will "vote" on each point to determine its class. To obtain an optimal value for $k$ the `train` method of the `caret` package is utilized:

```{r train-knn, out.width = '90%'}
model.knn = train(collapse.Class~., 
                  data = df, 
                  method = 'knn', 
                  trControl = ctrl,
                  tuneGrid = expand.grid(k = seq(1, 21, by = 2)))
model.knn
ggplot(model.knn) + theme_bw()
```

The plot and model summary above indicate that $k = 5$ is optimal based on a 10-fold cross validation. It appears that model performance increases to this point and then drops off as k continues to increase. The confusion matrix for $k = 5$ is shown below:

```{r knn-cv-cm}
knn.cm = confusionMatrix(model.knn$pred$pred,model.knn$pred$obs)
plot_preds = cbind(plot_preds,model.knn$pred$pred)
knn.cm
```

It appears that this model is the best performing model explored so far, with an accuracy of `r round(knn.cm$overall[[1]], 4)`% and a TPR of `r round(knn.cm$byClass[[1]], 4)`%. Since the class of each prediction is determined by its k-nearest neighbor's "votes", there is no cutoff value to select, and this model can interprted as-is. A table of the KNN-model's results can be found below:

```{r knn-results, message=FALSE, warning=FALSE}
knn.results = data.frame(Model = 'KNN', Tuning = 'k=5', AUROC = 'NA', Threshold = 'NA', Accuracy = round(knn.cm$overall[[1]],4), TPR = round(knn.cm$byClass[[1]],4), FNR = round(1-knn.cm$byClass[[2]],4), Precision = round(knn.cm$byClass[[5]],4))
knitr::kable(knn.results)
```

## Penalized Logistic Regression (ElasticNet)

The final model examined in this exploration is a penalized logistic regression using ElasticNet. This model is similar to  Least Absolute Shrinkage and Selection Operator (LASSO) and Ridge regression, in that it includes a penalty term. However, ElasticNet regression combines the best of both of those models, in that it allows for some of the coefficients to shrink, and some to go to 0. This property may allow the model to outperform the others that have already been examined. 

### Tuning Parameters

To begin, the tuning parameters, $\alpha$ and $\lambda$ must be selected. The method `train` from the `caret` package was utilized to select these parameters:

```{r elnetmodel}
model.elnet = train(
  collapse.Class ~ .,
  data = df,
  method = "glmnet",
  family = 'binomial',
  preProcess = c('center','scale'),
  trControl = ctrl)
alpha = model.elnet$bestTune$alpha
lambda = model.elnet$bestTune$lambda
```

The `train` method examined 3 values for $\alpha$ and $\lambda$, and selected $\alpha = `r alpha`$ and $\lambda = `r lambda`$, indicating that the ElasticNet regression actually decided on a LASSO Regression due to $\alpha = `r alpha`$. The coefficients of the model selected is shown below:

```{r elnetform}
coef(model.elnet$finalModel, model.elnet$finalModel$lambdaOpt)
```

A visualization of the model performance at each value of $\alpha$ and $\lambda$ is shown below:

```{r elnet-param-selection}
ggplot(model.elnet) + geom_line() + geom_point() + labs(title = 'ElasticNet Model Performance by Tuning Parameter Choice')
```

The graphic indicates that the best value of the mixing percentage, $\alpha$ is 1 and the best value for the regularization parameter, $\lambda$ is 0.00832. The value of $\lambda$ indicates that the selected LASSO model very closely approximates a normal logistic regression model, as the penalty term is not heavily weighted. The low weight to the penalty term indicates that all three variables (`Red`, `Green`, and `Blue`) likely provide utility in classification of `BT` pixels vs `NBT` pixels.

### Threshold Selection

The model parameters above create a model with the following confusion matrix for a cutoff of 0.5:

```{r elnet-cv-cm}
confusionMatrix(model.elnet)
```

It appears that the ElasticNet model has very good performance, matching the performance of the other parametric models with an accuracy of 0.9952 and a TPR of 0.875. The ROC curve for the ElasticNet model is shown below:

```{r elnet-roc, message=FALSE, warning=FALSE, out.width = '90%'}
r = ggplot(model.elnet$pred, aes(m = BT, d = obs)) + 
  geom_roc(labels = FALSE, increasing = FALSE) +
  labs(title = 'Elasticnet Model ROC Curve') +
  xlab('False Negative Rate') +
  ylab('True Positive Rate')
auc = round(calc_auc(r)$AUC, 4)
r + annotate("text", x = .8, y = .15, label = paste("AUC =", round(calc_auc(r)$AUC, 4)))
```

The ROC curve for the model indicates that the ROC curve has an $AUC = `r auc`$, which indicates a very impressive model. Finally, the interactive plot below was utilized to improve the TPR of the model by selecting a more optimal cutoff value:

```{r elnet-cutoff, out.width = '90%'}
sens = c()
spec = c()
acc = c()
tnr = c()
cutoff = seq(0, 1, by=0.01)
for (i in 1:length(cutoff)){
  newpred = factor(ifelse(model.elnet$pred$BT > cutoff[i], "BT", "NBT"), levels = c("BT", "NBT"))
  sens[i] = sens_vec(model.elnet$pred$obs, newpred)
  spec[i] = spec_vec(model.elnet$pred$obs, newpred)
  acc[i] = accuracy_vec(model.elnet$pred$obs, newpred)
  tnr[i] = 1 - spec[i]
}
cutoff_plot_data = data.frame(Cutoff = cutoff, Sensitivity = sens, Specificity = spec, Accuracy = acc, TNR = tnr)
p = ggplot(reshape2::melt(cutoff_plot_data, id.var='Cutoff')) +
  geom_line(aes(x = Cutoff, y = value, color = variable)) +
  scale_x_continuous(limits = c(0,1), breaks = seq(0,1,0.1)) +
  labs(title = 'Elasticnet Regression Model Performance by Cutoff Value') +
  xlab('Probability Cutoff Value')
ggplotly(p, dynamicTicks = TRUE) %>% rangeslider() %>% layout(hovermode = 'x')
```

A cutoff of 0.05 was selected, as TPR did not increase significantly beyond this point. The associated confusion matrix for the cutoff of 0.05 is shown below:

```{r elnet-cm}
newpred = factor(ifelse(model.elnet$pred$BT > 0.05, "BT", "NBT"), levels = c("BT", "NBT"))
plot_preds = cbind(plot_preds,model.knn$pred$pred)
elnet.cm = confusionMatrix(newpred, model.elnet$pred$obs)
elnet.cm
```

By decreasing the cutoff value to 0.05, the model's TPR increases to 0.939! However, the overall performance of the model suffers in this case, reducing the overall model accuracy to 0.955. However, this value was chosen to make sure that as many people in need were reached as possible. A summary table of the model results can be found below:

```{r elnet-results, message=FALSE, warning=FALSE}
elnet.results = data.frame(Model = 'Elasticnet', Tuning = c('alpha = 1, lambda = 8.32e-0.5'), AUROC = round(calc_auc(r)$AUC, 4), Threshold = 0.1, Accuracy = round(elnet.cm$overall[[1]],4), TPR = round(elnet.cm$byClass[[1]],4), FNR = round(1-elnet.cm$byClass[[2]],4), Precision = round(elnet.cm$byClass[[5]],4))
knitr::kable(elnet.results)
```

# Results (Cross-Validation)

The summary of the results from each of the model fits can be found below:

```{r results-table}
results = rbind(logistic.results, lda.results, qda.results, knn.results, elnet.results)
knitr::kable(results)
```

Each of the results was the average generated from a 10-fold cross validation of the data and the selection of the optimal cutoff value.

# Conclusions

### Conclusion \#1 

Out of the 5 models tested, K-Nearest Neighbors with $k = 5$ appears to be the best performing model. This is not surprising, as the 3D scatterplot generated during the exploratory data analysis indicated that the decision boundary may be highly non-linear. The flexible KNN model created a highly non-linear decision boundary which allowed the model to predict the presence of blue tarps very accurately. A visualization of the model predictions is shown below:

```{r 3d-decision}
preds = predict(model.knn, newdata = df)
classification = preds == df$collapse.Class
classification = data.frame(preds, classification)
classification = ifelse(classification$preds == 'BT', 
                        ifelse(classification$classification == TRUE, 'TP', 'FP'),
                        ifelse(classification$classification == TRUE, 'TN', 'FN'))
classification = as.factor(classification)
fig <- plot_ly(df, x = ~Red, y = ~Green, z = ~Blue, color = ~classification, colors = c('cornflowerblue', 'tomato', '#BF382A','#0C4B8E'))
fig <- fig %>% add_markers()
fig <- fig %>% layout(title = 'Distribution of Predictions in 3D Parameter Space',
                      scene = list(xaxis = list(title = 'Red'),
                                   yaxis = list(title = 'Green'),
                                   zaxis = list(title = 'Blue')))

fig
```

The traditional drawback of using a flexible model such as KNN is that there is high variance associated with these models. However, due to the large number of data points in this dataset the KNN model's 10-fold cross validation performance was excellent. If a smaller dataset was used to train each model, KNN may have had a larger cross validation error due to its natural higher variance. Overall, there can be a moderately-high level of confidence in the cross-validation results, as the dataset is very large compared to the number of variables and classes to predict.

### Conclusion \#2

The selected model, K-Nearest Neighbors, would be very helpful to aid humanitarian relief efforts for two reasons. First, aid services could have a high degree of confidence in the suggestions, as the KNN model has a very high TPR of 95.63%. This indicates that when the model indicates that an area contains blue tarps, the user can have a high degree of confidence in it. Second, the model has an overall accuracy of over 99%, therefore the aid services could use the model to aid decision making in where to deploy resources. High accuracy is important as false postives and false negatives both waste precious time and resources that could be deployed to help people in need. 

### Conclusion \#3

To further improve this model's performance and utility there are several options that could be explored in future projects. First, supplemental algorithms could also be developed to indicate if a prediction falls sufficiently close to the prediction boundary and to flag it for further review by humans. 

Next, additional data on latitude and longitude locations of each of the data points could also allow for algorithms to identify clusters of blue tarps in physical space. The addition of location data would allow aid services to deploy their resources even more effectively.

Finally, data pre-processing and feature engineering could be explored further to increase the true positive rate further. Upsampling methods such as SMOTE could be used to increase the prevalence of the blue tarp feature in the dataset, which could improve the model's predictive power for that class. Likewise, downsampling techniques could be used to balance the data by removing some of the NBT observations from the training dataset.


### Conclusion \#4

While training and evaluating each of these models, the run time of each algorithm was also observed. The following observations were made:

1. While KNN was the best performing model for this application, it was also the slowest to train, with a significantly longer run time than any of the other models. If there were significantly more data points, it would be prudent to split the data into training and test sets, perform the model fit and cross validation on the training set, and then evaluate the final model performance using the test set. 

2. The run time of the ElasticNet logistic regression model was also somewhat longer than that of the normal logistic regression model, LDA, and QDA models. For larger data sets it may also be appropriate to perform the training-test split on this model as well.

3. The run time of the Logistic Regression, LDA, and QDA models were similar and much smaller than that of the KNN or ElasticNet models. This property could make them useful in situations where aid resources had a larger data set to process and limited access to large computing resources.

### Conclusion \#5

This dataset is a very good candidate for predictive modeling tools for three reasons. First, the dataset contains only features that are important for prediction, making the task of feature selection easier. Second, each feature also has the same scaling as all of the other features (0-255 for RBG values), removing the need for some pre-processing activities. Finally, the dataset is large compared to the number of features in each of the models, which reduces the amount of variance in the final models.

# Supplementary Materials

This project was completed in the following environment:

```{r sessioninfo}
sessionInfo()
```

